[33mcommit 947f531c5aa9b356436e2e6a16601e7fb6c77e08[m
Author: Cat like fish <tangfeng.email@qq.com>
Date:   Wed May 11 20:26:03 2022 +0800

    keep

[1mdiff --git a/hexo-blog/source/_posts/Build-tree.md b/hexo-blog/source/_posts/Build-tree.md[m
[1mnew file mode 100644[m
[1mindex 0000000..a84623b[m
[1m--- /dev/null[m
[1m+++ b/hexo-blog/source/_posts/Build-tree.md[m
[36m@@ -0,0 +1,58 @@[m
[32m+[m[32m---[m
[32m+[m[32mtitle: 根据数组生成二叉树[m
[32m+[m[32mcategories: [算法][m
[32m+[m[32mtags: [二叉树生成][m
[32m+[m[32m---[m
[32m+[m
[32m+[m[32m#[m[41m [m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m# 定义二叉树[m
[32m+[m
[32m+[m[32m```c++[m
[32m+[m[32mstruct TreeNode{[m
[32m+[m[41m  [m	[32mint val;[m
[32m+[m[32m    TreeNode* left;[m
[32m+[m[32m    TreeNode* right;[m
[32m+[m[32m    TreeNode(int _val):val(_val){};[m
[32m+[m[32m};[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m# 层序遍历产生[m
[32m+[m
[32m+[m[32m```c++[m
[32m+[m[32m#include <vector>[m
[32m+[m[32m#include <queue>[m
[32m+[m
[32m+[m[32mint main(){[m
[32m+[m	[32mvector<int> tree = {'1','#','1','#','1','#','1','#','1'};[m
[32m+[m[32m    int length = tree.size();[m
[32m+[m	[32mqueue<TreeNode*> Q;[m
[32m+[m[32m    TreeNode* root;[m
[32m+[m[32m    if(tree[0]=='1'){[m
[32m+[m[32m        root = new TreeNode(0);[m
[32m+[m[41m    [m	[32mQ.push(root);[m
[32m+[m[32m    }[m
[32m+[m[32m    int index = 0;[m
[32m+[m[32m    while(!Q.empty()){[m
[32m+[m[32m        int len = Q.size();[m
[32m+[m[32m        for(int i=0;i<len;i++){[m
[32m+[m[32m            TreeNode* temp = Q.front();[m
[32m+[m[32m            Q.pop();[m
[32m+[m[32m            index++;[m
[32m+[m[32m            if(index<length&&tree[index]=='1'){[m
[32m+[m[32m                temp->left = new TreeNode(0);[m
[32m+[m[32m                Q.push(temp->left);[m
[32m+[m[32m            }[m
[32m+[m[32m            index++;[m
[32m+[m[32m            if(index<length&&tree[index]=='1'){[m
[32m+[m[32m                temp->right = new TreeNode(0);[m
[32m+[m[32m                Q.push(temp->right);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m	[32mreturn 0;[m
[32m+[m[32m}[m
[32m+[m[32m```[m
[32m+[m
[1mdiff --git "a/hexo-blog/source/_posts/c-\345\206\205\345\255\230\346\250\241\345\236\213\345\222\214\345\216\237\345\255\220\346\223\215\344\275\234.md" "b/hexo-blog/source/_posts/c-\345\206\205\345\255\230\346\250\241\345\236\213\345\222\214\345\216\237\345\255\220\346\223\215\344\275\234.md"[m
[1mnew file mode 100644[m
[1mindex 0000000..0438de2[m
[1m--- /dev/null[m
[1m+++ "b/hexo-blog/source/_posts/c-\345\206\205\345\255\230\346\250\241\345\236\213\345\222\214\345\216\237\345\255\220\346\223\215\344\275\234.md"[m
[36m@@ -0,0 +1,11 @@[m
[32m+[m[32m---[m
[32m+[m[32mtitle: c++内存模型和原子操作[m
[32m+[m[32mdate: 2022-05-10 09:53:32[m
[32m+[m[32mtags: [原子操作][m
[32m+[m[32mcategories: [算法][m
[32m+[m[32m---[m
[32m+[m
[32m+[m
[32m+[m[32m----------------------------[m
[32m+[m
[32m+[m[32m# 1. c++中的原子操作及其类别[m
[1mdiff --git "a/hexo-blog/source/_posts/c-\345\244\232\347\272\277\347\250\213\344\272\244\346\233\277\346\211\223\345\215\260AB.md" "b/hexo-blog/source/_posts/c-\345\244\232\347\272\277\347\250\213\344\272\244\346\233\277\346\211\223\345\215\260AB.md"[m
[1mnew file mode 100644[m
[1mindex 0000000..d1d53a7[m
[1m--- /dev/null[m
[1m+++ "b/hexo-blog/source/_posts/c-\345\244\232\347\272\277\347\250\213\344\272\244\346\233\277\346\211\223\345\215\260AB.md"[m
[36m@@ -0,0 +1,67 @@[m
[32m+[m[32m---[m
[32m+[m[32mtitle: c++多线程交替打印AB[m
[32m+[m[32mdate: 2022-05-09 15:09:30[m
[32m+[m[32mtags: [条件变量,多线程][m
[32m+[m[32mcategories: [c++][m
[32m+[m[32m---[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m-----------------------------[m
[32m+[m
[32m+[m[32m# c++交替打印AB[m
[32m+[m
[32m+[m[32m```c++[m
[32m+[m[32m#include <iostream>[m
[32m+[m[32m#include <thread>[m
[32m+[m[32m#include <mutex>[m
[32m+[m[32m#include <condition_variable>[m
[32m+[m
[32m+[m[32musing namespace std;[m
[32m+[m
[32m+[m[32mmutex mtx;[m
[32m+[m[32mcondition_variable cond_;[m
[32m+[m[32mbool flag = true;[m
[32m+[m
[32m+[m[32mvoid func1(){[m
[32m+[m[32m    unique_lock<mutex> locker(mtx);[m
[32m+[m[32m    while(true){[m
[32m+[m[32m/*[m[41m [m
[32m+[m[32m   调用时, 调用线程会判断条件，如果条件是false，则阻塞并释放锁，如果条件是true，则直接跳过wait执行下面的操作[m
[32m+[m[32m   如果阻塞，在被其他线程调用notify唤醒后，尝试获取锁，如果获取锁，再判断条件是否满足，如果是true，则继续执行下面的操作，如果是false，则对互斥量解锁，并阻塞该线程[m
[32m+[m[32m*/[m
[32m+[m[32m        // 第一次执行由于flag==true不阻塞[m[41m [m
[32m+[m[32m        cond_.wait(locker,[]->bool {return flag;}); // 阻塞时释放锁，执行时获取锁[m
[32m+[m[32m        flag = false;[m
[32m+[m[32m        cout<<"AA";[m
[32m+[m[32m        cond_.notify_one(); // 调用时，线程two被唤醒，但由于线程one还没释放锁，线程two阻塞，等待线程one释放，当线程one再次执行wait,由于flag==flase，所以线程one会被阻塞，同时释放锁，这时线程two获得锁，判断flag==flase，执行下一步，最后又唤醒one，重复如此[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid func2(){[m
[32m+[m[32m    unique_lock<mutex> locker(mtx);[m
[32m+[m[32m    while(true){[m
[32m+[m[32m        cond_.wait(locker,[]->bool {return !flag;});[m
[32m+[m[32m        flag = true;[m
[32m+[m[32m        cout<<"BB";[m
[32m+[m[32m        cond_.notify_one();[m
[32m+[m[32m    }[m[41m    [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mint main(){[m
[32m+[m[32m    thread one(func1);[m
[32m+[m[32m    thread two(func2);[m
[32m+[m[32m    one.join();[m
[32m+[m[32m    two.join();[m
[32m+[m[32m    return 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[41m    [m
[32m+[m[32m```[m
[32m+[m
[1mdiff --git "a/hexo-blog/source/_posts/c-\345\257\271\350\261\241\347\232\204\347\211\271\346\256\212\346\210\220\345\221\230\345\207\275\346\225\260.md" "b/hexo-blog/source/_posts/c-\345\257\271\350\261\241\347\232\204\347\211\271\346\256\212\346\210\220\345\221\230\345\207\275\346\225\260.md"[m
[1mnew file mode 100644[m
[1mindex 0000000..912dfaa[m
[1m--- /dev/null[m
[1m+++ "b/hexo-blog/source/_posts/c-\345\257\271\350\261\241\347\232\204\347\211\271\346\256\212\346\210\220\345\221\230\345\207\275\346\225\260.md"[m
[36m@@ -0,0 +1,6 @@[m
[32m+[m[32m---[m
[32m+[m[32mtitle: c++对象的特殊成员函数[m
[32m+[m[32mdate: 2022-05-06 11:09:58[m
[32m+[m[32mcategories: [c++][m
[32m+[m[32mtags: [c++对象][m
[32m+[m[32m---[m
[1mdiff --git "a/hexo-blog/source/_posts/c-\346\213\267\350\264\235\346\236\204\351\200\240\345\207\275\346\225\260\344\270\272\344\273\200\344\271\210\345\217\257\344\273\245\350\256\277\351\227\256\345\217\246\344\270\200\344\270\252\345\257\271\350\261\241\347\232\204\347\247\201\346\234\211\346\210\220\345\221\230.md" "b/hexo-blog/source/_posts/c-\346\213\267\350\264\235\346\236\204\351\200\240\345\207\275\346\225\260\344\270\272\344\273\200\344\271\210\345\217\257\344\273\245\350\256\277\351\227\256\345\217\246\344\270\200\344\270\252\345\257\271\350\261\241\347\232\204\347\247\201\346\234\211\346\210\220\345\221\230.md"[m
[1mnew file mode 100644[m
[1mindex 0000000..ce59704[m
[1m--- /dev/null[m
[1m+++ "b/hexo-blog/source/_posts/c-\346\213\267\350\264\235\346\236\204\351\200\240\345\207\275\346\225\260\344\270\272\344\273\200\344\271\210\345\217\257\344\273\245\350\256\277\351\227\256\345\217\246\344\270\200\344\270\252\345\257\271\350\261\241\347\232\204\347\247\201\346\234\211\346\210\220\345\221\230.md"[m
[36m@@ -0,0 +1,71 @@[m
[32m+[m[32m---[m
[32m+[m[32mtitle: c++拷贝构造函数为什么可以访问另一个对象的私有成员[m
[32m+[m[32mcategories: [c++][m
[32m+[m[32mtags: [c++对象][m
[32m+[m[32m---[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m-----------------------------------------[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m-------------------------------------------------------------[m
[32m+[m
[32m+[m[32m```c++[m
[32m+[m[32mclass Test{[m
[32m+[m[32mpublic:[m
[32m+[m[32m    /* 默认构造函数 */[m
[32m+[m[32m    Test(int _value = 0):value(_value){}[m
[32m+[m
[32m+[m[32m    /* 复制构造函数 */[m
[32m+[m[32m    Test(const Test& rhs){[m
[32m+[m[32m        this->value = rhs.value;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    void print(const Test& rhs){[m
[32m+[m[32m        cout<<rhs.value<<endl;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32mprivate:[m
[32m+[m[32m    int value;[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mint main(){[m
[32m+[m[32m    Test t(1);[m
[32m+[m[32m    Test t2(t);[m
[32m+[m[32m    Test t3(2);[m
[32m+[m[32m    /* 通过对象public函数访问另一个对象的私有变量 */[m
[32m+[m[32m    t3.print(t2);[m[41m [m
[32m+[m[32m    // cout<<t2.value<<endl; // 通过对象访问私有成员变量，编译出错[m
[32m+[m[32m    return 0;[m
[32m+[m[32m}[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m​        **封装是编译期的概念，是针对类型而非对象的，在类的成员函数中可以访问同类型实例对象的私有成员变量**[m
[32m+[m
[32m+[m[32m具体的解析如下：**从变量value的符号是怎么解析的分析**．[m
[32m+[m
[32m+[m[32m**1.确定符号的查找域**[m
[32m+[m
[32m+[m[32m当编译器发现value变量时，它会在value变量所属的对象rhs的类域中寻找该符号．[m
[32m+[m
[32m+[m[32m**2.确定当前域中哪些符号可以访问**[m
[32m+[m
[32m+[m[32m由第1步可知，当前查找的域是类域，而print函数在Test类体中，所以print可以访问Test类中的所有变量(包括私有成员变量)，因而value符号在Test类域中被找到．[m
[32m+[m
[32m+[m[32mmain函数不在Test类体中，所以main函数不可以访问Test类域中的私有成员变量．[m
[32m+[m
[32m+[m[32m**3.符号已查找到，编译通过**[m
[32m+[m
[32m+[m[32m类成员变量的访问权限是编译器强加的，编译器可以找到value，通过编译，自然就可以访问到value变量的值．[m
[32m+[m
[32m+[m[32m**直觉上，我们会以为代码中value符号的查找域应该是对象rhs对应的作用域，然而C++编译器的实现却是在对象rhs的类域查找value符号．**[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m参考文献：[m
[32m+[m
[32m+[m[32m1. [c++私有成员变量的理解](https://www.cnblogs.com/dwdxdy/archive/2012/07/17/2595741.html)[m
[1mdiff --git "a/hexo-blog/source/_posts/\345\215\225\344\276\213\346\250\241\345\274\217.md" "b/hexo-blog/source/_posts/\345\215\225\344\276\213\346\250\241\345\274\217.md"[m
[1mindex 7ea522d..aeebc26 100644[m
[1m--- "a/hexo-blog/source/_posts/\345\215\225\344\276\213\346\250\241\345\274\217.md"[m
[1m+++ "b/hexo-blog/source/_posts/\345\215\225\344\276\213\346\250\241\345\274\217.md"[m
[36m@@ -1,7 +1,114 @@[m
 ---[m
 title: 单例模式[m
[31m-date: 2022-04-26 21:17:23[m
 categories: [设计模式][m
 tags: [单例模式][m
 ---[m
[32m+[m[32m# 饿汉模式[m
[32m+[m
[32m+[m[32m```c++[m
[32m+[m[32m#include <iostream>[m
[32m+[m
[32m+[m[32musing namespace std;[m
[32m+[m
[32m+[m[32mclass HungrySingleton{[m
[32m+[m[32mprivate:[m
[32m+[m[32m    int count = 0;[m
[32m+[m[32m    static HungrySingleton* instance;[m
[32m+[m[32m    HungrySingleton() = default;[m
[32m+[m[32mpublic:[m
[32m+[m[32m    ~HungrySingleton() = default;[m
[32m+[m[32m    static HungrySingleton* getInstance(){[m
[32m+[m[32m        return instance;[m
[32m+[m[32m    }[m
[32m+[m[32m    void showMessage(){[m
[32m+[m[32m        cout<<count<<endl;[m
[32m+[m[32m    }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m/* 初始化类静态变量 */[m
[32m+[m[32mHungrySingleton* HungrySingleton::instance = new HungrySingleton();[m
[32m+[m
[32m+[m[32mint main(){[m
[32m+[m[32m    HungrySingleton* object = HungrySingleton::getInstance();[m
[32m+[m[32m    object->showMessage();[m
[32m+[m[32m    return 0;[m
[32m+[m[32m}[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m# 懒汉模式[m
[32m+[m
[32m+[m[32m## 线程安全（双重校验锁）[m
[32m+[m
[32m+[m[32m```c++[m
[32m+[m[32m#include <iostream>[m
[32m+[m[32m#include <mutex>[m
[32m+[m
[32m+[m[32musing namespace std;[m
[32m+[m
[32m+[m[32mclass LazySingleton{[m
[32m+[m[32mprivate:[m
[32m+[m[32m    static LazySingleton* instance;[m
[32m+[m[32m    static mutex _lock;[m
[32m+[m[32m    int count = 1;[m
[32m+[m[32m    LazySingleton() = default;[m
[32m+[m[32mpublic:[m
[32m+[m[32m    ~LazySingleton() = default;[m
[32m+[m[32m    static LazySingleton* getInstance(){[m
[32m+[m[32m        /* 缩小锁粒度，提高效率 */[m
[32m+[m[32m        if(instance==nullptr){[m
[32m+[m[32m            lock_guard<mutex> locker(_lock);[m
[32m+[m[32m            if(instance== nullptr){[m
[32m+[m[32m                instance = new LazySingleton;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return instance;[m
[32m+[m[32m    }[m
[32m+[m[32m    void showMessage(){[m
[32m+[m[32m        cout<<count;[m
[32m+[m[32m    }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m/* 初始化类静态变量 */[m
[32m+[m[32mmutex LazySingleton::_lock;[m
[32m+[m[32mLazySingleton* LazySingleton::instance = nullptr;[m
[32m+[m
[32m+[m[32mint main() {[m
[32m+[m[32m    LazySingleton* object = LazySingleton::getInstance();[m
[32m+[m[32m    object->showMessage();[m
[32m+[m[32m    return 0;[m
[32m+[m[32m}[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m## 线程安全（局部静态变量）[m
[32m+[m
[32m+[m[32m```c++[m
[32m+[m[32m#include <iostream>[m
[32m+[m
[32m+[m[32mclass LazySingleton{[m
[32m+[m[32mprivate:[m
[32m+[m[32m    int count = 1;[m
[32m+[m[32m    LazySingleton() = default;[m
[32m+[m[32mpublic:[m
[32m+[m[32m    ~LazySingleton() = default;[m
[32m+[m[32m    static LazySingleton* getInstance(){[m
[32m+[m[32m        /* 局部静态变量只会在第一次声明的时候初始化，在c++11以及之后的版本可以做到线程安全[m[41m [m
[32m+[m[32m        1.变量在代码第一次执行到变量声明的地方时初始化。[m
[32m+[m		[32m2.初始化过程中发生异常的话视为未完成初始化，未完成初始化的话，需要下次有代码执行到相同位置时再次初始化。[m
[32m+[m[32m        3.在当前线程执行到需要初始化变量的地方时，如果有其他线程正在初始化该变量，则阻塞当前线程，直到初始化完成为止。[m
[32m+[m[32m        4.如果初始化过程中发生了对初始化的递归调用，则视为未定义行为[m
[32m+[m[32m        */[m
[32m+[m[32m        static LazySingleton instance;[m
[32m+[m[32m        return &instance;[m
[32m+[m[32m    }[m
[32m+[m[32m    void showMessage(){[m
[32m+[m[32m        cout<<count;[m
[32m+[m[32m    }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mint main() {[m
[32m+[m[32m    LazySingleton* object = LazySingleton::getInstance();[m
[32m+[m[32m    object->showMessage();[m
[32m+[m[32m    return 0;[m
[32m+[m[32m}[m
[32m+[m[32m```[m
 [m
[1mdiff --git "a/hexo-blog/source/_posts/\346\231\272\350\203\275\346\214\207\351\222\210\347\232\204\347\256\200\345\215\225\345\256\236\347\216\260.md" "b/hexo-blog/source/_posts/\346\231\272\350\203\275\346\214\207\351\222\210\347\232\204\347\256\200\345\215\225\345\256\236\347\216\260.md"[m
[1mnew file mode 100644[m
[1mindex 0000000..5bae8d5[m
[1m--- /dev/null[m
[1m+++ "b/hexo-blog/source/_posts/\346\231\272\350\203\275\346\214\207\351\222\210\347\232\204\347\256\200\345\215\225\345\256\236\347\216\260.md"[m
[36m@@ -0,0 +1,229 @@[m
[32m+[m[32m---[m
[32m+[m[32mtitle: 智能指针的简单实现[m
[32m+[m[32mdate: 2022-05-06 09:31:04[m
[32m+[m[32mtags: [智能指针][m
[32m+[m[32mcategories: [c++][m
[32m+[m[32m---[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m--------------------------------------[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m# shared_ptr的简单实现(非线程安全)[m
[32m+[m
[32m+[m[32m主要包括以下成员函数：[m
[32m+[m
[32m+[m[32m1. 构造函数[m
[32m+[m
[32m+[m[32m2. 析构函数[m
[32m+[m
[32m+[m[32m3. 拷贝构造函数[m
[32m+[m
[32m+[m[32m4. operator=()[m
[32m+[m[32m5. operator*()[m
[32m+[m[32m6. operator->()[m
[32m+[m
[32m+[m[32m```c++[m
[32m+[m[32m#include <iostream>[m
[32m+[m[32m#include <cassert>[m
[32m+[m
[32m+[m[32musing namespace std;[m
[32m+[m
[32m+[m[32mtemplate<typename T>[m
[32m+[m[32mclass shared_ptr{[m
[32m+[m[32mprivate:[m
[32m+[m[32m    size_t* p_count;[m
[32m+[m[32m    T* ptr;[m
[32m+[m[32mpublic:[m
[32m+[m[32m    explicit shared_ptr(T* _ptr = nullptr):ptr(_ptr){[m
[32m+[m[32m        if(ptr) p_count = new size_t(1);[m
[32m+[m[32m        else p_count = new size_t(0);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    shared_ptr(const shared_ptr<T>& rhs){[m
[32m+[m[32m        ptr = rhs.ptr;[m
[32m+[m[32m        p_count = rhs.p_count;[m
[32m+[m[32m        (*p_count)++;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    /* 返回引用是为了满足连续复制 比如A=B=C=1 */[m
[32m+[m[32m    shared_ptr<T>& operator=(const shared_ptr<T>& rhs){[m
[32m+[m[32m        /* 处理“自我赋值” */[m
[32m+[m[32m        if(this == &rhs) return *this;[m
[32m+[m
[32m+[m[32m        /* 如果shared_ptr之前指向一个对象，则需要释放掉相应资源 */[m
[32m+[m[32m        if(ptr){[m
[32m+[m[32m            (*p_count)--;[m
[32m+[m[32m            if((*p_count)==0){[m
[32m+[m[32m                delete ptr;[m
[32m+[m[32m                delete p_count;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /* 复制对象，并增加计数 */[m
[32m+[m[32m        ptr = rhs.ptr;[m
[32m+[m[32m        p_count = rhs.p_count;[m
[32m+[m[32m        (*p_count)++;[m
[32m+[m[32m        return *this;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    /* 重载* */[m
[32m+[m[32m    T& operator*(){[m
[32m+[m[32m        assert(ptr);[m
[32m+[m[32m        return *ptr;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    /* 重载-> */[m
[32m+[m[32m    T* operator->(){[m
[32m+[m[32m        assert(ptr);[m
[32m+[m[32m        return ptr;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    size_t use_count() const {[m
[32m+[m[32m        return *p_count;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    ~shared_ptr(){[m
[32m+[m[32m        (*p_count)--;[m
[32m+[m[32m        if((*p_count)==0){[m
[32m+[m[32m            delete ptr;[m
[32m+[m[32m            delete p_count;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mclass test{[m
[32m+[m[32mpublic:[m
[32m+[m[32m    int a = 1;[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mint main(){[m
[32m+[m[32m    shared_ptr<test> p1(new test); // 默认构造函数[m
[32m+[m[32m    cout<<p1->a<<endl;[m
[32m+[m[32m    cout<<(*p1).a<<endl;[m
[32m+[m[32m    {[m
[32m+[m[32m        shared_ptr<test> p2(p1); // 拷贝构造函数[m
[32m+[m[32m        cout<<"p2:"<<p2.use_count()<<endl;[m
[32m+[m[32m        shared_ptr<test> p3 = p2; // 拷贝构造函数[m
[32m+[m[32m        cout<<"p2:"<<p2.use_count()<<endl;[m
[32m+[m[32m        cout<<"p3:"<<p3.use_count()<<endl;[m
[32m+[m
[32m+[m[32m        shared_ptr<test> p4(new test);[m
[32m+[m[32m        cout<<"Before p4:"<<p4.use_count()<<endl;[m
[32m+[m[32m        p4 = p3; // operator= 赋值[m
[32m+[m[32m        cout<<"After p4:"<<p4.use_count()<<endl;[m
[32m+[m[32m    }[m
[32m+[m[32m    cout<<"p1:"<<p1.use_count()<<endl;[m
[32m+[m[32m}[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m# unique_ptr的简单实现[m
[32m+[m
[32m+[m[32m主要包括一下成员函数：[m
[32m+[m
[32m+[m[32m1. 构造函数;[m
[32m+[m
[32m+[m[32m2. 移动构造函数;[m
[32m+[m[32m3. 析构函数；[m
[32m+[m[32m4. 禁用拷贝构造函数;[m
[32m+[m[32m5. 禁用拷贝赋值函数 operator=();[m
[32m+[m[32m6. reset(): 释放源资源，指向新资源;[m
[32m+[m[32m7. release(): 返回资源，放弃对资源的管理;[m
[32m+[m[32m8. get(): 返回资源，只是公外部使用，依然管理资源;[m
[32m+[m[32m9. operator bool(): 是否持有资源;[m
[32m+[m[32m10. operator*();[m
[32m+[m[32m11. operator->();[m
[32m+[m
[32m+[m[32m```c++[m
[32m+[m[32m#include <iostream>[m
[32m+[m[32m#include <cassert>[m
[32m+[m
[32m+[m[32mtemplate<typename T>[m
[32m+[m[32mclass unique_ptr{[m
[32m+[m[32mprivate:[m
[32m+[m	[32mT* ptr;[m
[32m+[m[41m    [m
[32m+[m[32mpublic:[m
[32m+[m[32m    unique_ptr(T* _ptr):ptr(_ptr){};[m
[32m+[m[32m    /* 移动构造函数 */[m
[32m+[m[32m    unique_ptr(unique_ptr&& rhs):ptr(rhs.release()){};[m
[32m+[m[41m        [m
[32m+[m[32m    ~unique_ptr(){[m
[32m+[m[32m        if(ptr) delete ptr;[m
[32m+[m[32m        ptr = nullptr;[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    /* 需要禁止的默认成员函数 */[m
[32m+[m[32m    unique_ptr(const unique_ptr& rhs) = delete;[m
[32m+[m[32m    unique_ptr& operator=(const unique_ptr& rhs) = delete;[m
[32m+[m[41m    [m
[32m+[m[32mpublic:[m
[32m+[m[32m    /* 释放源资源，指向新资源 */[m
[32m+[m[32m    void reset(T* _ptr){[m
[32m+[m[32m        if(ptr) delete ptr;[m
[32m+[m[32m        ptr = _ptr;[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    /* 返回资源，放弃对资源的管理 */[m
[32m+[m[32m    T* release(){[m
[32m+[m[32m        T* pTemp = ptr;[m
[32m+[m[32m        ptr = nullptr;[m
[32m+[m[32m        return pTemp;[m
[32m+[m[32m    }[m
[32m+[m[32m    /* 返回资源，只是公外部使用，依然管理资源 */[m
[32m+[m[32m    T* get(){[m
[32m+[m[32m        return ptr;[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32mpublic:[m
[32m+[m[32m    /* 重载bool() */[m
[32m+[m[32m    explicit operator bool() const{[m
[32m+[m[32m        return ptr != nullptr;[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    T& operator*(){[m
[32m+[m[32m        assert(ptr);[m
[32m+[m[32m        return *ptr;[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    T* operator->(){[m
[32m+[m[32m        assert(ptr);[m
[32m+[m[32m        return ptr;[m
[32m+[m[32m    }[m[41m   [m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mclass test{[m
[32m+[m[32mpublic:[m
[32m+[m[32m    int a = 1;[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mint main(){[m
[32m+[m[32m    unique_ptr<test> x(new test);[m
[32m+[m[32m    cout<<"x->a:"<<(*x).a<<endl;[m
[32m+[m[32m    unique_ptr<test> y = move(x);[m
[32m+[m[32m    //test* aaa = x.get();[m
[32m+[m[32m    if(!x) cout<<"Moved x!!"<<endl;[m
[32m+[m[32m    cout<<"y->a:"<<y->a<<endl;[m
[32m+[m[32m}[m
[32m+[m[32m```[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m参考文献：[m
[32m+[m
[32m+[m[32m[1] https://zhuanlan.zhihu.com/p/344953368[m
[32m+[m
[32m+[m[32m[2] https://www.ccppcoding.com/archives/202[m
[1mdiff --git "a/hexo-blog/source/_posts/\351\235\242\350\257\225\345\270\270\350\247\201\347\232\204\346\216\222\345\272\217.md" "b/hexo-blog/source/_posts/\351\235\242\350\257\225\345\270\270\350\247\201\347\232\204\346\216\222\345\272\217.md"[m
[1mnew file mode 100644[m
[1mindex 0000000..ffcf076[m
[1m--- /dev/null[m
[1m+++ "b/hexo-blog/source/_posts/\351\235\242\350\257\225\345\270\270\350\247\201\347\232\204\346\216\222\345\272\217.md"[m
[36m@@ -0,0 +1,209 @@[m
[32m+[m[32m---[m
[32m+[m[32mtitle: 面试常见的排序[m
[32m+[m[32mdate: 2022-05-05 12:39:54[m
[32m+[m[32mtags: [排序][m
[32m+[m[32mcategories: [算法,面试][m
[32m+[m[32m---[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m---------------------------[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m![各种排序复杂度以及稳定性](https://cdn.jsdelivr.net/gh/DJtang/picx_ima@main/各种排序复杂度以及稳定性.43qxyiwpqwc0.webp)[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m## 一、快速排序[m
[32m+[m
[32m+[m[32m​	快速排序平均时间复杂度为o(nlogn)，最坏时间复杂度为o(n^2)，不稳定;[m
[32m+[m
[32m+[m[32m​	主要可以通过以下几种方式来优化：[m
[32m+[m
[32m+[m[32m1. 三数取中，使选择的“标杆”能够尽量的将数组平均划分成两半，避免选择到边界值使时间复杂度退化到o(n^2)；[m
[32m+[m[32m2. 双指针操作，减少在对比时的交换次数；[m
[32m+[m[32m3. 每次遍历集中放置与“标杆”相同的值，减少递归深度；[m
[32m+[m
[32m+[m[32m​[m[41m	[m
[32m+[m
[32m+[m[32m```c++[m
[32m+[m[32m#include <iostream>[m
[32m+[m[32m#include <vector>[m
[32m+[m[32m#include <algorithm>[m
[32m+[m[32musing namespace std;[m
[32m+[m
[32m+[m[32mvoid quickSort(int start, int end, vector<int>& nums){[m
[32m+[m[32m    if(start>=end) return;[m
[32m+[m[32m    int left = start;[m
[32m+[m[32m    int right = end;[m
[32m+[m[32m    int mid = (left + right) / 2;[m
[32m+[m[32m    /* 三数取中 */[m
[32m+[m[32m    if((nums[left]<nums[mid]&&nums[mid]<nums[right])||(nums[left]>nums[mid]&&nums[mid]>nums[right])){[m
[32m+[m[32m        swap(nums[left],nums[mid]);[m
[32m+[m[32m    }[m
[32m+[m[32m    else if((nums[left]<nums[right]&&nums[right]<nums[mid])||(nums[left]>nums[right]&&nums[right]>nums[mid])){[m
[32m+[m[32m        swap(nums[left],nums[right]);[m
[32m+[m[32m    }[m
[32m+[m[32m    /* 双指针 */[m
[32m+[m[32m    while(left<right){[m
[32m+[m[32m        while(left<right&&nums[start]<=nums[right]) right--;[m
[32m+[m[32m        while(left<right&&nums[start]>=nums[left]) left++;[m
[32m+[m[32m        if(left<right) swap(nums[left],nums[right]);[m
[32m+[m[32m    }[m
[32m+[m[32m    swap(nums[start],nums[left]);[m
[32m+[m[41m    [m
[32m+[m[32m    /* 递归调用 */[m
[32m+[m[32m    quickSort(start,left-1,nums);[m
[32m+[m[32m    quickSort(left+1,end,nums);[m
[32m+[m[32m    return;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mint main() {[m
[32m+[m[32m    vector<int> nums = {2,5,1,6,8,4,2,8,1,25,8};[m
[32m+[m[32m    quickSort(0,nums.size()-1,nums);[m
[32m+[m[32m    for(int i=0;i<nums.size();i++){[m
[32m+[m[32m        cout<<nums[i]<<",";[m
[32m+[m[32m    }[m
[32m+[m[32m    return 0;[m
[32m+[m[32m}[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m## 二、归并排序[m
[32m+[m
[32m+[m[32m归并排序时间复杂度为o(nlogn)，空间复杂度为o(n)，稳定;[m
[32m+[m
[32m+[m[32m```c++[m
[32m+[m[32m#include <iostream>[m
[32m+[m[32m#include <vector>[m
[32m+[m[32m#include <algorithm>[m
[32m+[m[32musing namespace std;[m
[32m+[m
[32m+[m[32mvoid mergeSort(int start, int end, vector<int>& nums, vector<int>& temp){[m
[32m+[m[32m    if(start>=end) return;[m
[32m+[m[32m    /* 递归分割 */[m
[32m+[m[32m    int mid = (start + end) / 2;[m
[32m+[m[32m    mergeSort(start,mid,nums,temp);[m
[32m+[m[32m    mergeSort(mid+1,end,nums,temp);[m
[32m+[m[32m    /* 合并 */[m
[32m+[m[32m    int index = start;[m
[32m+[m[32m    int left = start;[m
[32m+[m[32m    int right = mid + 1;[m
[32m+[m[32m    while(left<=mid||right<=end){[m
[32m+[m[32m        int x = left<=mid?nums[left]:INT_MAX;[m
[32m+[m[32m        int y = right<=end?nums[right]:INT_MAX;[m
[32m+[m[32m        temp[index] = min(x,y);[m
[32m+[m[32m        if(temp[index]==x) left++;[m
[32m+[m[32m        else right++;[m
[32m+[m[32m        index++;[m
[32m+[m[32m    }[m
[32m+[m[41m  [m	[32m// 复制结果[m
[32m+[m[32m    for(int i=start;i<=end;i++) nums[i] = temp[i];[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mint main() {[m
[32m+[m[32m    vector<int> nums = {2,5,1,6,8,4,2,8,1,25,8};[m
[32m+[m[32m    vector<int> temp(nums.size(),0);[m
[32m+[m[32m    mergesSort(0,nums.size()-1,nums,temp);[m
[32m+[m[32m    for(int i=0;i<nums.size();i++){[m
[32m+[m[32m        cout<<nums[i]<<",";[m
[32m+[m[32m    }[m
[32m+[m[32m    return 0;[m
[32m+[m[32m}[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m## 三、堆排序[m
[32m+[m
[32m+[m[32m堆排序时间复杂度为o(nlogn)，空间时间复杂度为o(1)，不稳定;[m
[32m+[m
[32m+[m[32m```c++[m
[32m+[m[32m#include <iostream>[m
[32m+[m[32m#include <vector>[m
[32m+[m[32m#include <algorithm>[m
[32m+[m[32musing namespace std;[m
[32m+[m
[32m+[m[32m/* 向下调整堆 */[m
[32m+[m[32mvoid siftDown(int index, int end, vector<int>& nums){[m
[32m+[m[32m    if(index>=end) return;[m
[32m+[m[32m    int left = index*2 + 1;[m
[32m+[m[32m    int right = left + 1;[m
[32m+[m[32m    int max_index = index;[m
[32m+[m[32m    if(left<=end&&nums[left]>nums[max_index]) max_index = left;[m
[32m+[m[32m    if(right<=end&&nums[right]>nums[max_index]) max_index = right;[m
[32m+[m[32m    if(max_index!=index){[m
[32m+[m[32m        swap(nums[index],nums[max_index]);[m
[32m+[m[32m        siftDown(max_index,end,nums);[m
[32m+[m[32m    }[m
[32m+[m[32m    return;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid heapSort(vector<int>& nums){[m
[32m+[m[32m    int len = nums.size();[m
[32m+[m[32m    /* 建堆 */[m
[32m+[m[32m    for(int i=len/2-1;i>=0;i--){[m
[32m+[m[32m        siftDown(i,len-1,nums);[m
[32m+[m[32m    }[m
[32m+[m[41m 	[m
[32m+[m[32m    /* 堆排序 */[m
[32m+[m[32m    for(int i=len-1;i>0;i--){[m
[32m+[m[41m    [m	[32msiftDown(0,i,nums);[m
[32m+[m[32m        swap(nums[0],nums[i]);[m
[32m+[m[32m    }[m
[32m+[m[32m    return;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mint main() {[m
[32m+[m[32m    vector<int> nums = {2,5,1,6,8,4,2,8,1,25,8};[m
[32m+[m[32m    heapSort(nums);[m
[32m+[m[32m    for(int i=0;i<nums.size();i++){[m
[32m+[m[32m        cout<<nums[i]<<",";[m
[32m+[m[32m    }[m
[32m+[m[32m    return 0;[m
[32m+[m[32m}[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m## 四、希尔排序[m
[32m+[m
[32m+[m[32m希尔排序时间复杂度为o(nlogn)，空间时间复杂度为o(1)，不稳定;[m
[32m+[m
[32m+[m[32m```c++[m
[32m+[m[32m#include <iostream>[m
[32m+[m[32m#include <vector>[m
[32m+[m[32m#include <algorithm>[m
[32m+[m[32musing namespace std;[m
[32m+[m
[32m+[m[32mvoid shellSort(vector<int>& nums){[m
[32m+[m[32m    int len = nums.size();[m
[32m+[m[32m    for(int k=2;k>0;k/=2){[m
[32m+[m[32m        for(int i=k;i<len;i++){[m
[32m+[m[32m            for(int j=i-k;j>=0;j-=k){[m
[32m+[m[32m                if(nums[j]>nums[j+k]) swap(nums[j],nums[j+k]);[m
[32m+[m[32m                else break;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m[32mint main() {[m
[32m+[m[32m    vector<int> nums = {2,5,1,6,8,4,2,8,1,25,8};[m
[32m+[m[32m    shellSort(nums);[m
[32m+[m[32m    for(int i=0;i<nums.size();i++){[m
[32m+[m[32m        cout<<nums[i]<<",";[m
[32m+[m[32m    }[m
[32m+[m[32m    return 0;[m
[32m+[m[32m}[m
[32m+[m[32m```[m
[32m+[m
[1mdiff --git "a/hexo-blog/source/_posts/\351\253\230\345\271\266\345\217\221\347\263\273\347\273\237\350\256\276\350\256\241-\346\225\260\346\215\256\345\272\223\347\257\207.md" "b/hexo-blog/source/_posts/\351\253\230\345\271\266\345\217\221\347\263\273\347\273\237\350\256\276\350\256\241-\346\225\260\346\215\256\345\272\223\347\257\207.md"[m
[1mnew file mode 100644[m
[1mindex 0000000..38e907a[m
[1m--- /dev/null[m
[1m+++ "b/hexo-blog/source/_posts/\351\253\230\345\271\266\345\217\221\347\263\273\347\273\237\350\256\276\350\256\241-\346\225\260\346\215\256\345\272\223\347\257\207.md"[m
[36m@@ -0,0 +1,5 @@[m
[32m+[m[32m---[m
[32m+[m[32mtitle: 高并发系统设计-数据库篇[m
[32m+[m[32mdate: 2022-05-11 17:33:19[m
[32m+[m[32mtags:[m
[32m+[m[32m---[m
