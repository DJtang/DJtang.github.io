[{"title":"Hello World","url":"/2022/04/26/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","tags":["test"]},{"title":"hexo+github搭建自己的博客","url":"/2022/04/26/hexo+github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/","content":"准备工作GitHub账号注册一个github账号 \nGitHub申请账号\n安装Git Git安装(Windows)\n安装NodeJSNodeJS安装及配置(Windows)\n创建仓库\n在GitHub上创建一个新的代码仓库用于保存我们的网页。\n\n点击Your repositories，进入仓库页面。\n\n点击New按钮，进入仓库创建页面。\n填写仓库名，格式必须为&lt;用户名&gt;.github.io，然后点击Create repository。\n访问我们的主页  https://djtang.github.io/\n\n安装Hexo采用Hexo来创建我们的博客网站，Hexo 是一个基于NodeJS的静态博客网站生成器，使用Hexo不需开发，只要进行一些必要的配置即可生成一个个性化的博客网站，非常方便。点击进入 官网。\n安装 Hexo\nnpm install -g hexo-cli\n\n查看版本\nhexo -v\n\n创建一个项目 hexo-blog 并初始化\nhexo init hexo-blogcd hexo-blognpm install\n\n本地启动\nhexo ghexo server\n\n更换主题官网推荐主题\n我使用的是Keep\n创建文章hexo new post 测试文章\n\n发布到GitHub Pages安装hexo-deployer-git\nnpm install hexo-deployer-git --save\n\n修改根目录下的 _config.yml，配置 GitHub 相关信息\ndeploy:  type: git  repo: https://github.com/yaorongke/yaorongke.github.io.git  branch: main  token: ghp_3KakcaPHerunNRyMerofcFd9pblU282FSbsY\n\n静态图片使用PicX图床\n参考：\n[1]: https://blog.csdn.net/yaorongke/article/details/119089190\t“GitHub Pages + Hexo搭建个人博客网站，史上最全教程”[2]: https://keep-docs.xpoet.cn/usage-tutorial/quick-start.html\t“hexo-theme-keep”\n","categories":["环境配置"],"tags":["日常"]},{"title":"单例模式","url":"/2022/04/26/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","content":"饿汉模式#include &lt;iostream&gt;using namespace std;class HungrySingleton&#123;private:    int count = 0;    static HungrySingleton* instance;    HungrySingleton() = default;public:    ~HungrySingleton() = default;    static HungrySingleton* getInstance()&#123;        return instance;    &#125;    void showMessage()&#123;        cout&lt;&lt;count&lt;&lt;endl;    &#125;&#125;;/* 初始化类静态变量 */HungrySingleton* HungrySingleton::instance = new HungrySingleton();int main()&#123;    HungrySingleton* object = HungrySingleton::getInstance();    object-&gt;showMessage();    return 0;&#125;\n\n懒汉模式线程安全（双重校验锁）#include &lt;iostream&gt;#include &lt;mutex&gt;using namespace std;class LazySingleton&#123;private:    static LazySingleton* instance;    static mutex _lock;    int count = 1;    LazySingleton() = default;public:    ~LazySingleton() = default;    static LazySingleton* getInstance()&#123;        /* 缩小锁粒度，提高效率 */        if(instance==nullptr)&#123;            lock_guard&lt;mutex&gt; locker(_lock);            if(instance== nullptr)&#123;                instance = new LazySingleton;            &#125;        &#125;        return instance;    &#125;    void showMessage()&#123;        cout&lt;&lt;count;    &#125;&#125;;/* 初始化类静态变量 */mutex LazySingleton::_lock;LazySingleton* LazySingleton::instance = nullptr;int main() &#123;    LazySingleton* object = LazySingleton::getInstance();    object-&gt;showMessage();    return 0;&#125;\n\n线程安全（局部静态变量）#include &lt;iostream&gt;class LazySingleton&#123;private:    int count = 1;    LazySingleton() = default;public:    ~LazySingleton() = default;    static LazySingleton* getInstance()&#123;        /* 局部静态变量只会在第一次声明的时候初始化，在c++11以及之后的版本可以做到线程安全         1.变量在代码第一次执行到变量声明的地方时初始化。\t\t2.初始化过程中发生异常的话视为未完成初始化，未完成初始化的话，需要下次有代码执行到相同位置时再次初始化。        3.在当前线程执行到需要初始化变量的地方时，如果有其他线程正在初始化该变量，则阻塞当前线程，直到初始化完成为止。        4.如果初始化过程中发生了对初始化的递归调用，则视为未定义行为        */        static LazySingleton instance;        return &amp;instance;    &#125;    void showMessage()&#123;        cout&lt;&lt;count;    &#125;&#125;;int main() &#123;    LazySingleton* object = LazySingleton::getInstance();    object-&gt;showMessage();    return 0;&#125;\n\n","categories":["设计模式"],"tags":["单例模式"]}]