[{"title":"Hello World","url":"/2022/04/26/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","tags":["test"]},{"title":"hexo+github搭建自己的博客","url":"/2022/04/26/hexo+github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/","content":"准备工作GitHub账号注册一个github账号 \nGitHub申请账号\n安装Git Git安装(Windows)\n安装NodeJSNodeJS安装及配置(Windows)\n创建仓库\n在GitHub上创建一个新的代码仓库用于保存我们的网页。\n\n点击Your repositories，进入仓库页面。\n\n点击New按钮，进入仓库创建页面。\n填写仓库名，格式必须为&lt;用户名&gt;.github.io，然后点击Create repository。\n访问我们的主页  https://djtang.github.io/\n\n安装Hexo采用Hexo来创建我们的博客网站，Hexo 是一个基于NodeJS的静态博客网站生成器，使用Hexo不需开发，只要进行一些必要的配置即可生成一个个性化的博客网站，非常方便。点击进入 官网。\n安装 Hexo\nnpm install -g hexo-cli\n\n查看版本\nhexo -v\n\n创建一个项目 hexo-blog 并初始化\nhexo init hexo-blogcd hexo-blognpm install\n\n本地启动\nhexo ghexo server\n\n更换主题官网推荐主题\n我使用的是Keep\n创建文章hexo new post 测试文章\n\n发布到GitHub Pages安装hexo-deployer-git\nnpm install hexo-deployer-git --save\n\n修改根目录下的 _config.yml，配置 GitHub 相关信息\ndeploy:  type: git  repo: https://github.com/yaorongke/yaorongke.github.io.git  branch: main  token: ghp_3KakcaPHerunNRyMerofcFd9pblU282FSbsY\n\n静态图片使用PicX图床\n参考：\n[1]: https://blog.csdn.net/yaorongke/article/details/119089190\t“GitHub Pages + Hexo搭建个人博客网站，史上最全教程”[2]: https://keep-docs.xpoet.cn/usage-tutorial/quick-start.html\t“hexo-theme-keep”\n","categories":["环境配置"],"tags":["日常"]},{"title":"单例模式","url":"/2022/04/26/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","content":"饿汉模式#include &lt;iostream&gt;using namespace std;class HungrySingleton&#123;private:    int count = 0;    static HungrySingleton* instance;    HungrySingleton() = default;public:    ~HungrySingleton() = default;    static HungrySingleton* getInstance()&#123;        return instance;    &#125;    void showMessage()&#123;        cout&lt;&lt;count&lt;&lt;endl;    &#125;&#125;;/* 初始化类静态变量 */HungrySingleton* HungrySingleton::instance = new HungrySingleton();int main()&#123;    HungrySingleton* object = HungrySingleton::getInstance();    object-&gt;showMessage();    return 0;&#125;\n\n懒汉模式线程安全（双重校验锁）#include &lt;iostream&gt;#include &lt;mutex&gt;using namespace std;class LazySingleton&#123;private:    static LazySingleton* instance;    static mutex _lock;    int count = 1;    LazySingleton() = default;public:    ~LazySingleton() = default;    static LazySingleton* getInstance()&#123;        /* 缩小锁粒度，提高效率 */        if(instance==nullptr)&#123;            lock_guard&lt;mutex&gt; locker(_lock);            if(instance== nullptr)&#123;                instance = new LazySingleton;            &#125;        &#125;        return instance;    &#125;    void showMessage()&#123;        cout&lt;&lt;count;    &#125;&#125;;/* 初始化类静态变量 */mutex LazySingleton::_lock;LazySingleton* LazySingleton::instance = nullptr;int main() &#123;    LazySingleton* object = LazySingleton::getInstance();    object-&gt;showMessage();    return 0;&#125;\n\n线程安全（局部静态变量）#include &lt;iostream&gt;class LazySingleton&#123;private:    int count = 1;    LazySingleton() = default;public:    ~LazySingleton() = default;    static LazySingleton* getInstance()&#123;        /* 局部静态变量只会在第一次声明的时候初始化，在c++11以及之后的版本可以做到线程安全         1.变量在代码第一次执行到变量声明的地方时初始化。\t\t2.初始化过程中发生异常的话视为未完成初始化，未完成初始化的话，需要下次有代码执行到相同位置时再次初始化。        3.在当前线程执行到需要初始化变量的地方时，如果有其他线程正在初始化该变量，则阻塞当前线程，直到初始化完成为止。        4.如果初始化过程中发生了对初始化的递归调用，则视为未定义行为        */        static LazySingleton instance;        return &amp;instance;    &#125;    void showMessage()&#123;        cout&lt;&lt;count;    &#125;&#125;;int main() &#123;    LazySingleton* object = LazySingleton::getInstance();    object-&gt;showMessage();    return 0;&#125;\n\n","categories":["设计模式"],"tags":["单例模式"]},{"title":"根据数组生成二叉树","url":"/2022/04/28/Build-tree/","content":"定义二叉树struct TreeNode&#123;  \tint val;    TreeNode* left;    TreeNode* right;    TreeNode(int _val):val(_val)&#123;&#125;;&#125;;\n\n层序遍历产生#include &lt;vector&gt;#include &lt;queue&gt;int main()&#123;\tvector&lt;int&gt; tree = &#123;&#x27;1&#x27;,&#x27;#&#x27;,&#x27;1&#x27;,&#x27;#&#x27;,&#x27;1&#x27;,&#x27;#&#x27;,&#x27;1&#x27;,&#x27;#&#x27;,&#x27;1&#x27;&#125;;    int length = tree.size();\tqueue&lt;TreeNode*&gt; Q;    TreeNode* root;    if(tree[0]==&#x27;1&#x27;)&#123;        root = new TreeNode(0);    \tQ.push(root);    &#125;    int index = 0;    while(!Q.empty())&#123;        int len = Q.size();        for(int i=0;i&lt;len;i++)&#123;            TreeNode* temp = Q.front();            Q.pop();            index++;            if(index&lt;length&amp;&amp;tree[index]==&#x27;1&#x27;)&#123;                temp-&gt;left = new TreeNode(0);                Q.push(temp-&gt;left);            &#125;            index++;            if(index&lt;length&amp;&amp;tree[index]==&#x27;1&#x27;)&#123;                temp-&gt;right = new TreeNode(0);                Q.push(temp-&gt;right);            &#125;        &#125;    &#125;\treturn 0;&#125;\n\n","categories":["算法"],"tags":["二叉树生成"]},{"title":"c++拷贝构造函数为什么可以访问另一个对象的私有成员","url":"/2022/04/28/c-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98/","content":"\n\nclass Test&#123;public:    /* 默认构造函数 */    Test(int _value = 0):value(_value)&#123;&#125;    /* 复制构造函数 */    Test(const Test&amp; rhs)&#123;        this-&gt;value = rhs.value;    &#125;    void print(const Test&amp; rhs)&#123;        cout&lt;&lt;rhs.value&lt;&lt;endl;    &#125;private:    int value;&#125;;int main()&#123;    Test t(1);    Test t2(t);    Test t3(2);    /* 通过对象public函数访问另一个对象的私有变量 */    t3.print(t2);     // cout&lt;&lt;t2.value&lt;&lt;endl; // 通过对象访问私有成员变量，编译出错    return 0;&#125;\n\n​        封装是编译期的概念，是针对类型而非对象的，在类的成员函数中可以访问同类型实例对象的私有成员变量\n具体的解析如下：从变量value的符号是怎么解析的分析．\n1.确定符号的查找域\n当编译器发现value变量时，它会在value变量所属的对象rhs的类域中寻找该符号．\n2.确定当前域中哪些符号可以访问\n由第1步可知，当前查找的域是类域，而print函数在Test类体中，所以print可以访问Test类中的所有变量(包括私有成员变量)，因而value符号在Test类域中被找到．\nmain函数不在Test类体中，所以main函数不可以访问Test类域中的私有成员变量．\n3.符号已查找到，编译通过\n类成员变量的访问权限是编译器强加的，编译器可以找到value，通过编译，自然就可以访问到value变量的值．\n直觉上，我们会以为代码中value符号的查找域应该是对象rhs对应的作用域，然而C++编译器的实现却是在对象rhs的类域查找value符号．\n参考文献：\n\nc++私有成员变量的理解\n\n","categories":["c++"],"tags":["c++对象"]},{"title":"面试常见的排序","url":"/2022/05/05/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F/","content":"\n\n一、快速排序​\t快速排序平均时间复杂度为o(nlogn)，最坏时间复杂度为o(n^2)，不稳定;\n​\t主要可以通过以下几种方式来优化：\n\n三数取中，使选择的“标杆”能够尽量的将数组平均划分成两半，避免选择到边界值使时间复杂度退化到o(n^2)；\n双指针操作，减少在对比时的交换次数；\n每次遍历集中放置与“标杆”相同的值，减少递归深度；\n\n​\t\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;void quickSort(int start, int end, vector&lt;int&gt;&amp; nums)&#123;    if(start&gt;=end) return;    int left = start;    int right = end;    int mid = (left + right) / 2;    /* 三数取中 */    if((nums[left]&lt;nums[mid]&amp;&amp;nums[mid]&lt;nums[right])||(nums[left]&gt;nums[mid]&amp;&amp;nums[mid]&gt;nums[right]))&#123;        swap(nums[left],nums[mid]);    &#125;    else if((nums[left]&lt;nums[right]&amp;&amp;nums[right]&lt;nums[mid])||(nums[left]&gt;nums[right]&amp;&amp;nums[right]&gt;nums[mid]))&#123;        swap(nums[left],nums[right]);    &#125;    /* 双指针 */    while(left&lt;right)&#123;        while(left&lt;right&amp;&amp;nums[start]&lt;=nums[right]) right--;        while(left&lt;right&amp;&amp;nums[start]&gt;=nums[left]) left++;        if(left&lt;right) swap(nums[left],nums[right]);    &#125;    swap(nums[start],nums[left]);        /* 递归调用 */    quickSort(start,left-1,nums);    quickSort(left+1,end,nums);    return;&#125;int main() &#123;    vector&lt;int&gt; nums = &#123;2,5,1,6,8,4,2,8,1,25,8&#125;;;    quickSort(0,nums.size()-1,nums);    for(int i=0;i&lt;nums.size();i++)&#123;        cout&lt;&lt;nums[i]&lt;&lt;&quot;,&quot;;    &#125;    return 0;&#125;\n\n二、归并排序归并排序时间复杂度为o(nlogn)，空间复杂度为o(n)，稳定;\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;void mergeSort(int start, int end, vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; temp)&#123;    if(start&gt;=end) return;    /* 递归分割 */    int mid = (start + end) / 2;    mergeSort(start,mid,nums,temp);    mergeSort(mid+1,end,nums,temp);    /* 合并 */    int index = start;    int left = start;    int right = mid + 1;    while(left&lt;=mid||right&lt;=end)&#123;        int x = left&lt;=mid?nums[left]:INT_MAX;        int y = right&lt;=end?nums[right]:INT_MAX;        temp[index] = min(x,y);        if(temp[index]==x) left++;        else right++;        index++;    &#125;  \t// 复制结果    for(int i=start;i&lt;=end;i++) nums[i] = temp[i];&#125;int main() &#123;    vector&lt;int&gt; nums = &#123;2,5,1,6,8,4,2,8,1,25,8&#125;;;    vector&lt;int&gt; temp(nums.size(),0);    mergesSort(0,nums.size()-1,nums,temp);    for(int i=0;i&lt;nums.size();i++)&#123;        cout&lt;&lt;nums[i]&lt;&lt;&quot;,&quot;;    &#125;    return 0;&#125;\n\n三、堆排序堆排序时间复杂度为o(nlogn)，空间时间复杂度为o(1)，不稳定;\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;/* 向下调整堆 */void siftDown(int index, int end, vector&lt;int&gt;&amp; nums)&#123;    if(index&gt;=end) return;    int left = index*2 + 1;    int right = left + 1;    int max_index = index;    if(left&lt;=end&amp;&amp;nums[left]&gt;nums[max_index]) max_index = left;    if(right&lt;=end&amp;&amp;nums[right]&gt;nums[max_index]) max_index = right;    if(max_index!=index)&#123;        swap(nums[index],nums[max_index]);        siftDown(max_index,end,nums);    &#125;    return;&#125;void heapSort(vector&lt;int&gt;&amp; nums)&#123;    int len = nums.size();    /* 建堆 */    for(int i=len/2-1;i&gt;=0;i--)&#123;        siftDown(i,len-1,nums);    &#125; \t    /* 堆排序 */    for(int i=len-1;i&gt;0;i--)&#123;    \tsiftDown(0,i,nums);        swap(nums[0],nums[i]);    &#125;    return;&#125;int main() &#123;    vector&lt;int&gt; nums = &#123;2,5,1,6,8,4,2,8,1,25,8&#125;;;    heapSort(nums);    for(int i=0;i&lt;nums.size();i++)&#123;        cout&lt;&lt;nums[i]&lt;&lt;&quot;,&quot;;    &#125;    return 0;&#125;\n\n四、希尔排序希尔排序时间复杂度为o(nlogn)，空间时间复杂度为o(1)，不稳定;\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;void shellSort(vector&lt;int&gt;&amp; nums)&#123;    int len = nums.size();    for(int k=2;k&gt;0;k/=2)&#123;        for(int i=k;i&lt;len;i++)&#123;            for(int j=i-k;j&gt;=0;j-=k)&#123;                if(nums[j]&gt;nums[j+k]) swap(nums[j],nums[j+k]);                else break;            &#125;        &#125;    &#125;&#125;int main() &#123;    vector&lt;int&gt; nums = &#123;2,5,1,6,8,4,2,8,1,25,8&#125;;;    shellSort(nums);    for(int i=0;i&lt;nums.size();i++)&#123;        cout&lt;&lt;nums[i]&lt;&lt;&quot;,&quot;;    &#125;    return 0;&#125;\n\n","categories":["算法","面试"],"tags":["排序"]}]